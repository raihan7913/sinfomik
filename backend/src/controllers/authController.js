// backend/src/controllers/authController.js
const { getDb } = require('../config/db');
const { createHash } = require('crypto'); // Untuk hashing SHA256 (sesuai data dummy Python)
const bcrypt = require('bcryptjs'); // Untuk membandingkan hash password (jika menggunakan bcrypt)
const jwt = require('jsonwebtoken'); // Untuk JWT authentication
const JWT_SECRET = process.env.JWT_SECRET || 'sinfomik_super_secret_key_2025_change_in_production_please';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '5h'; // Testing: 5h, Production: 24h

// Helper untuk hashing password (sesuai dengan yang digunakan di Python hashlib.sha256)
function hashPasswordPythonStyle(password) {
    return createHash('sha256').update(password).digest('hex');
}

// Helper untuk hashing dengan bcrypt (more secure)
async function hashPasswordBcrypt(password) {
    const salt = await bcrypt.genSalt(10);
    return await bcrypt.hash(password, salt);
}

exports.login = (req, res) => {
    const { username, password, user_type } = req.body;
    const db = getDb();

    let tableName;
    let usernameField;
    let idField;
    let nameField;

    if (user_type === 'siswa') {
        return res.status(400).json({ message: 'Role siswa tidak memiliki akses login.' });
    }

    switch (user_type) {
        case 'admin':
            tableName = 'Admin';
            usernameField = 'username';
            idField = 'id_admin';
            nameField = 'nama';
            break;
        case 'guru':
            tableName = 'Guru';
            usernameField = 'username';
            idField = 'id_guru';
            nameField = 'nama_guru';
            break;
        default:
            return res.status(400).json({ message: 'Tipe pengguna tidak valid.' });
    }

    const query = `SELECT ${idField}, ${nameField}, password_hash FROM ${tableName} WHERE ${usernameField} = $1`;

    db.get(query, [username], async (err, user) => {
        if (err) {
            console.error('Database error during login:', err.message);
            return res.status(500).json({ message: 'Terjadi kesalahan server.' });
        }
        if (!user) {
            return res.status(401).json({ message: 'Username atau password salah.' });
        }

        // Bandingkan password - support both SHA256 (legacy) and bcrypt
        let isPasswordValid = false;
        
        // Try bcrypt first (if password was hashed with bcrypt)
        if (user.password_hash.startsWith('$2a$') || user.password_hash.startsWith('$2b$')) {
            isPasswordValid = await bcrypt.compare(password, user.password_hash);
        } else {
            // Fallback to SHA256 for legacy passwords
            isPasswordValid = hashPasswordPythonStyle(password) === user.password_hash;
            
            // If SHA256 worked, upgrade to bcrypt for better security
            if (isPasswordValid) {
                const newHash = await hashPasswordBcrypt(password);
                const updateQuery = `UPDATE ${tableName} SET password_hash = $1 WHERE ${idField} = $2`;
                db.run(updateQuery, [newHash, user[idField]], (err) => {
                    if (err) {
                        console.error('Failed to upgrade password hash:', err);
                    } else {
                        console.log(`✅ Password upgraded to bcrypt for ${user_type}: ${user[nameField]}`);
                    }
                });
            }
        }

        if (!isPasswordValid) {
            return res.status(401).json({ message: 'Username atau password salah.' });
        }

        // Generate JWT token - jwt.sign will auto-add 'iat' (issued-at) timestamp
        const token = jwt.sign(
            { 
                id: user[idField], 
                user_type: user_type, 
                nama: user[nameField]
            },
            JWT_SECRET,
            { expiresIn: JWT_EXPIRES_IN }
        );

        // Decode token to get the actual 'iat' timestamp generated by jwt.sign
        const decoded = jwt.decode(token);
        const issuedAt = decoded.iat; // This is the actual issued-at timestamp

        // Update last_login_timestamp to enforce single active session
        // IMPORTANT: Use callback to ensure DB is updated BEFORE responding to client
        const updateQuery = `UPDATE ${tableName} SET last_login_timestamp = $1 WHERE ${idField} = $2`;
        db.run(updateQuery, [issuedAt, user[idField]], function(err) {
            if (err) {
                console.error('Failed to update last_login_timestamp:', err);
                // Continue anyway, token is still valid
                console.log(`⚠️  Session update failed but proceeding with login`);
            } else {
                console.log(`✅ Session initialized for ${user_type}: ${user[nameField]} at timestamp ${issuedAt}`);
            }
            
            // RESPOND TO CLIENT ONLY AFTER DB UPDATE COMPLETES
            res.status(200).json({
                success: true,
                message: 'Login berhasil!',
                user: {
                    id: user[idField],
                    username: user[nameField],
                    type: user_type
                },
                token: token // JWT token untuk authentication
            });
        });
    });
};

// Endpoint untuk verify token dan extend session
exports.getCurrentUser = (req, res) => {
    // This endpoint is protected by verifyToken middleware, so token is already verified
    // Simply responding confirms the token is valid and session is active
    const user = req.user;
    
    res.status(200).json({
        success: true,
        user: {
            id: user.id,
            username: user.nama,
            type: user.user_type
        },
        message: 'Token masih aktif'
    });
};
